<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>An Introduction To Ruby Code blocks Part 2 | Thumbs Up Rails</title>
<meta name="generator" content="Jekyll v4.3.4" />
<meta property="og:title" content="An Introduction To Ruby Code blocks Part 2" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Shortcomings of Implicit Code Blocks In Part 1 of this series, examination of the shortcomings of Implicit code blocks in Ruby highlighted the fact that, they can’t be stored and therefore manipulated or passed around to be run later. They have to be executed instantly and inside the method to which they are passed." />
<meta property="og:description" content="Shortcomings of Implicit Code Blocks In Part 1 of this series, examination of the shortcomings of Implicit code blocks in Ruby highlighted the fact that, they can’t be stored and therefore manipulated or passed around to be run later. They have to be executed instantly and inside the method to which they are passed." />
<link rel="canonical" href="http://localhost:4000/ruby/2025/04/18/an-introduction-to-ruby-code-blocks-part-2.html" />
<meta property="og:url" content="http://localhost:4000/ruby/2025/04/18/an-introduction-to-ruby-code-blocks-part-2.html" />
<meta property="og:site_name" content="Thumbs Up Rails" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2025-04-18T01:18:00+03:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="An Introduction To Ruby Code blocks Part 2" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2025-04-18T01:18:00+03:00","datePublished":"2025-04-18T01:18:00+03:00","description":"Shortcomings of Implicit Code Blocks In Part 1 of this series, examination of the shortcomings of Implicit code blocks in Ruby highlighted the fact that, they can’t be stored and therefore manipulated or passed around to be run later. They have to be executed instantly and inside the method to which they are passed.","headline":"An Introduction To Ruby Code blocks Part 2","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/ruby/2025/04/18/an-introduction-to-ruby-code-blocks-part-2.html"},"url":"http://localhost:4000/ruby/2025/04/18/an-introduction-to-ruby-code-blocks-part-2.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Thumbs Up Rails" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Thumbs Up Rails</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">An Introduction To Ruby Code blocks Part 2</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2025-04-18T01:18:00+03:00" itemprop="datePublished">Apr 18, 2025
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h2 id="shortcomings-of-implicit-code-blocks">Shortcomings of Implicit Code Blocks</h2>
<p>In Part 1 of this series, examination of the shortcomings of  Implicit code blocks in Ruby highlighted the fact that, they can’t be stored and therefore manipulated or passed around to be run later. They have to be executed instantly and inside the method to which they are passed.</p>

<p>Consider these 2 methods below both of which are meant to solve the same problem, printing someone’s full name:</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">full_name</span>
  <span class="n">first</span> <span class="o">=</span> <span class="s2">"John"</span>
  <span class="n">last</span> <span class="o">=</span> <span class="s2">"Doe"</span>
  <span class="k">yield</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">)</span> <span class="k">if</span> <span class="nb">block_given?</span>
<span class="k">end</span>

<span class="n">full_name</span> <span class="k">do</span> <span class="o">|</span><span class="n">first_name</span><span class="p">,</span> <span class="n">last_name</span><span class="o">|</span>
  <span class="s2">"</span><span class="si">#{</span><span class="n">first_name</span><span class="si">}</span><span class="s2"> </span><span class="si">#{</span><span class="n">last_name</span><span class="si">}</span><span class="s2">"</span>
<span class="k">end</span>

<span class="c1">#OUTPUT</span>
<span class="s2">"John Doe"</span>
</code></pre></div></div>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">full_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">first_name</span><span class="p">)</span>
  <span class="n">firstname</span> <span class="o">=</span> <span class="n">first_name</span><span class="p">.</span><span class="nf">call</span>
  <span class="n">fullname</span> <span class="o">=</span> <span class="n">firstname</span> <span class="o">+</span> <span class="s2">" "</span> <span class="o">+</span> <span class="s2">"Doe"</span>
<span class="k">end</span>

<span class="n">full_name</span> <span class="k">do</span> 
  <span class="s2">"John"</span>
<span class="k">end</span>

<span class="c1">#OUTPUT</span>
<span class="s2">"John Doe"</span>
</code></pre></div></div>

<p>The first solution(method) employs yield and specifically the concept of Implicit code blocks in Ruby to solve the problem while the second utilizes Explicit code blocks to solve the same problem. For this exact problem, both these solutions are okay. However for use cases when we need to “<em>capture</em>” and “<em>save the code block for later execution</em>”, the limitations of solution 1 which utilizes Implicit code blocks become evident very quickly and we’ll see that the second solution i.e. the one employing explicit code blocks is better for the reasons highlighted below.</p>
<h2 id="comparison-between-explicit-and-implicit-code-blocks-in-ruby">Comparison between Explicit and Implicit Code Blocks in Ruby</h2>

<table>
  <thead>
    <tr>
      <th>Aspect</th>
      <th>Implicit Code blocks(yield version)</th>
      <th>Explicit code blocks(Proc version)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Can the block be stored?</td>
      <td>No. Can only be used inside the method</td>
      <td>Yes. Can be stored as a Proc object.</td>
    </tr>
    <tr>
      <td>Can the block re-used outside the method?</td>
      <td>No. Only called within the method</td>
      <td>Yes. Since explicit code blocks can be stored as Proc objects, these Proc objects can be used outside the method.</td>
    </tr>
    <tr>
      <td>Can the block be passed to other method?</td>
      <td>No. Only associated with the method to which its passed</td>
      <td>Yes. Explicit code blocks captured as Proc objects can be passed to other methods.</td>
    </tr>
  </tbody>
</table>

<h2 id="behind-the-scenes-of-how-ruby-handles-explicit-code-blocks">Behind the scenes of how Ruby handles Explicit code blocks</h2>

<p>Lets modify the fullname method a bit:</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">full_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">first_name</span><span class="p">)</span>
  <span class="nb">puts</span> <span class="n">first_name</span><span class="p">.</span><span class="nf">class</span>
  <span class="n">firstname</span> <span class="o">=</span> <span class="n">first_name</span><span class="p">.</span><span class="nf">call</span>
  <span class="n">fullname</span> <span class="o">=</span> <span class="n">firstname</span> <span class="o">+</span> <span class="s2">" "</span> <span class="o">+</span> <span class="s2">"Doe"</span>
<span class="k">end</span>
<span class="n">full_name</span> <span class="k">do</span> 
  <span class="s2">"John"</span>
<span class="k">end</span>

<span class="c1">#OUTPUT</span>
<span class="no">Proc</span>
<span class="s2">"John Doe"</span> 
</code></pre></div></div>

<p>When we pass a block to the above method, we can see that on checking for the class of the “first_name” object, the output is  “Proc” signifying that this is a Proc object. Here’s a step by step flow of how that happens:</p>

<ul>
  <li>Explicit code block passed to the full_name method is converted into a Proc object.</li>
  <li>Proc object is captured and assigned to and stored in the first_name parameter</li>
  <li>Inside the method, we call the Proc using:
    <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">first_name</span><span class="p">.</span><span class="nf">call</span>
</code></pre></div>    </div>
    <p>The above line executes the code block and returns the result of executing the explicit code block we passed to the method initially.</p>
  </li>
</ul>

<blockquote>
  <p>Call is a ruby method defined for Proc objects and since first_name is a Proc object, we can therefore call the “call” method on it.</p>
</blockquote>

<ul>
  <li>We assign the result of executing the explicit code block to a variable named “firstname”</li>
  <li>Using string concatenation, we add a string named “Doe” i.e the second name, to finally get the full name which is returned to us in the terminal. 
The conversion of an explicit code block into a Proc object is the reason for the flexibility associated with Explicit code blocks in ruby. Since we end up with a Proc object, we can use this object for all sorts of things from passing it to other methods as well as executing it at a later point in time.</li>
</ul>

<h2 id="the-importance-of-the-ampersand">The Importance of the Ampersand(&amp;)</h2>
<p>In case you’ve been observant, when defining the full_name method, we prefixed the “first_name” parameter with a &amp; symbol commonly known as the Ampersand symbol. 
By prefixing the “first_name” parameter with an Ampersand(&amp;) we let ruby know that a code block passed to the full_name method should be converted to a Proc object. Without it, we get an error below:</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mf">3.2</span><span class="o">.</span><span class="mi">6</span> <span class="p">:</span><span class="mo">036</span> <span class="o">&gt;</span> <span class="k">def</span> <span class="nf">full_name</span><span class="p">(</span><span class="n">first_name</span><span class="p">)</span>
<span class="mf">3.2</span><span class="o">.</span><span class="mi">6</span> <span class="p">:</span><span class="mo">037</span> <span class="o">&gt;</span>   <span class="n">firstname</span> <span class="o">=</span> <span class="n">first_name</span><span class="p">.</span><span class="nf">call</span>
<span class="mf">3.2</span><span class="o">.</span><span class="mi">6</span> <span class="p">:</span><span class="mo">03</span><span class="mi">8</span> <span class="o">&gt;</span>   <span class="n">full_name</span> <span class="o">=</span> <span class="n">firstname</span> <span class="o">+</span> <span class="s2">" "</span> <span class="o">+</span> <span class="s2">"Doe"</span>
<span class="mf">3.2</span><span class="o">.</span><span class="mi">6</span> <span class="p">:</span><span class="mo">03</span><span class="mi">9</span> <span class="o">&gt;</span> <span class="k">end</span>
 <span class="o">=&gt;</span> <span class="ss">:full_name</span> 
<span class="mf">3.2</span><span class="o">.</span><span class="mi">6</span> <span class="p">:</span><span class="mo">040</span> <span class="o">&gt;</span> <span class="n">full_name</span> <span class="k">do</span> 
<span class="mf">3.2</span><span class="o">.</span><span class="mi">6</span> <span class="p">:</span><span class="mo">041</span> <span class="o">&gt;</span>   <span class="s2">"John"</span>
<span class="mf">3.2</span><span class="o">.</span><span class="mi">6</span> <span class="p">:</span><span class="mo">042</span> <span class="o">&gt;</span> <span class="k">end</span>
<span class="p">(</span><span class="n">irb</span><span class="p">):</span><span class="mi">36</span><span class="ss">:in</span> <span class="sb">`full_name': wrong number of arguments (given 0, expected 1) (ArgumentError)
	from (irb):40:in `</span><span class="o">&lt;</span><span class="n">main</span><span class="o">&gt;</span><span class="s1">'
	from /usr/share/rvm/gems/ruby-3.2.6/gems/irb-1.15.1/exe/irb:9:in `&lt;top (required)&gt;'</span>
	<span class="n">from</span> <span class="sr">/usr/s</span><span class="n">hare</span><span class="o">/</span><span class="n">rvm</span><span class="o">/</span><span class="n">gems</span><span class="o">/</span><span class="n">ruby</span><span class="o">-</span><span class="mf">3.2</span><span class="o">.</span><span class="mi">6</span><span class="o">/</span><span class="n">bin</span><span class="o">/</span><span class="n">irb</span><span class="p">:</span><span class="mi">25</span><span class="ss">:in</span> <span class="sb">`load'
	from /usr/share/rvm/gems/ruby-3.2.6/bin/irb:25:in `</span><span class="o">&lt;</span><span class="n">main</span><span class="o">&gt;</span><span class="s1">'
	from /usr/share/rvm/gems/ruby-3.2.6/bin/ruby_executable_hooks:22:in `eval'</span>
	<span class="n">from</span> <span class="sr">/usr/s</span><span class="n">hare</span><span class="o">/</span><span class="n">rvm</span><span class="o">/</span><span class="n">gems</span><span class="o">/</span><span class="n">ruby</span><span class="o">-</span><span class="mf">3.2</span><span class="o">.</span><span class="mi">6</span><span class="o">/</span><span class="n">bin</span><span class="o">/</span><span class="n">ruby_executable_hooks</span><span class="p">:</span><span class="mi">22</span><span class="ss">:in</span> <span class="sb">`&lt;main&gt;'
3.2.6 :043 &gt; 
</span></code></pre></div></div>

<p>Without the ampersand, Ruby no longer knows how to handle the code block passed to it and expects the full_name method to  be called like any other method in Ruby. And since we defined the full_name method to have one parameter, namely the first_name, Ruby expects that the method should be called along with one argument, which is exactly why we get the error above. In simple terms, Ruby is saying:</p>

<p>“<em>Hey, you defined the “full_name” method to take an argument but you’ve called the “full_name” method without providing an argument.</em>”</p>

<p>There is a way for Ruby to understand that a block passed to a given method should be handled as an explicit code block even though you’ve left out the Ampersand.</p>

<p>Consider the code below:</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">full_name</span><span class="p">(</span><span class="n">first_name</span><span class="p">)</span>
  <span class="nb">puts</span> <span class="n">first_name</span><span class="p">.</span><span class="nf">class</span>
  <span class="n">firstname</span> <span class="o">=</span> <span class="n">first_name</span><span class="p">.</span><span class="nf">call</span>
  <span class="n">fullname</span> <span class="o">=</span> <span class="n">firstname</span> <span class="o">+</span> <span class="s2">" "</span> <span class="o">+</span> <span class="s2">"Doe"</span>
<span class="k">end</span>

<span class="n">full_name</span><span class="p">(</span><span class="no">Proc</span><span class="p">.</span><span class="nf">new</span> <span class="k">do</span>
  <span class="s2">"John"</span>
<span class="k">end</span><span class="p">)</span>

<span class="c1">#OUTPUT</span>
<span class="no">Proc</span>
 <span class="o">=&gt;</span> <span class="s2">"John Doe"</span>
</code></pre></div></div>

<p>In the above code, we see that the output is still the same as the initial “full_name” method regardless of the fact that we left out the Ampersand. The above code works because when passing the code block to the “full_name” method, we handled the conversion of the code block into a Proc object manually by calling Proc.new. 
In the output we also notice that the first_name object is a Proc object meaning the conversion of the code block into a Proc object was successful.</p>

<p>This highlights the importance of the Ampersand. For a given code block to be termed as an explicit code block, ruby has to convert it into a Proc object. This can be achieved either automatically(by prefixing the “first_name” parameter with the Ampersand(&amp;) and have Ruby handle the conversion of the code block into a Proc object behind the scenes as in the initial version of the full_name method) or manually where by we handle the conversion of the code block into a Proc object our selves by calling <strong>Proc.new</strong>. You can choose either based on what you prefer though my personal preference is to use the Ampersand as that’s one less thing to think about in case things go wrong.</p>

<p>When passing single line code blocks to methods for example the “full_name” method, you can use the syntax below:</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">full_name</span><span class="p">(</span><span class="no">Proc</span><span class="p">.</span><span class="nf">new</span><span class="p">{</span> <span class="s2">"John"</span> <span class="p">})</span>
<span class="no">Proc</span>
 <span class="o">=&gt;</span> <span class="s2">"John Doe"</span> 
</code></pre></div></div>

<p>The syntax above is equivalent to the one below and returns the same output.</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">full_name</span><span class="p">(</span><span class="no">Proc</span><span class="p">.</span><span class="nf">new</span> <span class="k">do</span>
  <span class="s2">"John"</span>
<span class="k">end</span><span class="p">)</span>
<span class="no">Proc</span>
 <span class="o">=&gt;</span> <span class="s2">"John Doe"</span> 
</code></pre></div></div>

<p>And that marks the end of this post. In case you missed part 1 of the series, you can check it out <a href="https://zhephyn.github.io/ruby/2025/04/16/an-introduction-to-ruby-code-blocks-part-1.html">here</a>.</p>

  </div><a class="u-url" href="/ruby/2025/04/18/an-introduction-to-ruby-code-blocks-part-2.html" hidden></a>
</article>

      </div>
    </main></body>

</html>
